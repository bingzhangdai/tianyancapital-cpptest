
## Prerequisite

* cmake >= 3.14
* g++/clang++需要支持至少c++11
* 网络通畅（因为使用了一些第三方库）

## 编译运行

```bash
cmake -S . -B build
cmake --build build
cd build && ctest --output-on-failure
```

## 1. 不同券商行情处理

因为要求不论接入多少券商，printMidPrice不能修改，于是考虑封装多态。后续可以引入c++ 依赖注入的库使得代码进一步好看，`problems/q1/market_data_processor.hpp`里`processors`容器作用其实也类似于DI的容器。

由于使用虚函数，性能可能有一定损失，可以在`PrintMidPrice`函数里使用`switch-case`做静态绑定，但这样如果接入新券商，就需要在里面增加一条`case`语句，并不是很符合题目要求。

## 2. 风控设计

不同产品的风控继承自同样的基类`IRisk`，首先过滤通用的风控要求，比如禁止某写股票的交易。之后按照`accountId`来选择对应的风控模块去过滤。

所有的风控策略可以从配置文件中load起来，同时监听文件，如果文件有更新，则做热加载更新策略（代码里没实现监听热加载，因为不用实现具体风控逻辑），这样可以做到快速应用新的风控策略，并且不需要重新编译或者重启进程。

风控策略判断里加了`unique_lock`，可以视业务逻辑不加锁或者加读写锁。

## 3. 回报分发

由于订单执行系统是个独立进程，而不同的模块间没有任何关系，在`Api`里hard code `ModuleX`扩展性也不好，于是考虑进程间通信，不同模块作为独立client端订阅`Api`的消息。

进程间通信有多种方式，共享内存的方式最为高效。通过引入`sys/ipc.h`和`sys/shm.h`可以实现最基础的进程交换数据要求。然而却有以下两个问题：

1. 如果client端没有及时读取数据，server端写覆盖了，这样会导致数据丢失或者读到的struct新旧数据混合（aka，读写并不是原子操作）。相比于丢失，新旧数据混合可能会导致一些undefined behaviors，这里可能需要锁，然而跨进程的锁机制很麻烦。

2. 跨平台问题，并不是所有操作系统都有这样的IPC支持，调试也很麻烦。

对应有如下解决办法：
1. 在shared memory上做一个（环形）队列，队列就是读/写的缓冲区，只要读/写基本上速度一致，读/写进程偶尔有些卡顿慢一点点也无关紧要。同时读进程一直不停轮询，如果有数据来了立即处理，来不及处理的可以放进本进程的内存队列。
2. 采用boost库替换操作系统c库解决跨平台问题。

或者我们引入消息队列来解决。ZMQ作为一个高效的消息队列，支持ipc协议，同样也是[零拷贝](http://wiki.zeromq.org/blog:zero-copy)。并且，如果client/server不在同一台机器上，ZMQ同样也可以支持socket通信，代码几乎不用做更改，系统扩展性更好。


## 4. 回报触发

题目等价于如何在`sendOrderInternal`里调用`onRtnOrder`。

